<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>Robotics CAD â€” Grid</title>
<style>
    body { margin: 0; overflow: hidden; }
    canvas { display: block; }
    button {
        position: absolute;
        top: 10px;
        left: 10px;
        z-index: 10;
        padding: 8px 12px;
        font-size: 16px;
    }
    #addPartBtn {
        top: 50px;
    }
</style>
</head>
<body>

<button onclick="window.history.back()">Back</button>
<button id="addPartBtn">Add Part</button>

<script type="module">
import * as THREE from 'https://cdn.jsdelivr.net/npm/three@0.152.2/build/three.module.js';

// --- Scene & Camera ---
const scene = new THREE.Scene();
scene.background = new THREE.Color(0xe0e0e0);

const camera = new THREE.PerspectiveCamera(70, window.innerWidth/window.innerHeight, 0.1, 100);
camera.position.set(10, 10, 10);
camera.lookAt(0, 0, 0);

// --- Renderer ---
const renderer = new THREE.WebGLRenderer({antialias: true});
renderer.setSize(window.innerWidth, window.innerHeight);
renderer.shadowMap.enabled = true;
document.body.appendChild(renderer.domElement);

// --- Lights ---
const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
scene.add(ambientLight);

const directionalLight = new THREE.DirectionalLight(0xffffff, 0.6);
directionalLight.position.set(10, 20, 10);
directionalLight.castShadow = true;
scene.add(directionalLight);

// --- Grid helper for the build plate ---
const gridHelper = new THREE.GridHelper(20, 40, 0x888888, 0xcccccc);
scene.add(gridHelper);

// --- Build plate ---
const plate = new THREE.Mesh(
    new THREE.PlaneGeometry(20, 20),
    new THREE.MeshStandardMaterial({color: 0xaaaaaa, side: THREE.DoubleSide})
);
plate.rotation.x = -Math.PI/2;
plate.receiveShadow = true;
scene.add(plate);

// --- Robot parts container ---
const parts = [];

// --- Function to create a part ---
function createPart(color=0xffa500, position={x:0, y:0.5, z:0}) {
    const cube = new THREE.Mesh(
        new THREE.BoxGeometry(1,1,1),
        new THREE.MeshStandardMaterial({color: color})
    );
    cube.position.set(position.x, position.y, position.z);
    cube.castShadow = true;
    cube.receiveShadow = true;
    scene.add(cube);
    parts.push(cube);
}

// --- Initial parts ---
createPart(0xffa500, {x:0, y:0.5, z:0});
createPart(0x0000ff, {x:2, y:0.5, z:0});
createPart(0xff0000, {x:-2, y:0.5, z:0});

// --- Raycaster & dragging ---
const raycaster = new THREE.Raycaster();
const mouse = new THREE.Vector2();
let selected = null;
let isDragging = false;

// --- Snap to grid (1 unit per cell) ---
function snapToGrid(value) { return Math.round(value); }

function getMouseOnPlane(event, planeY=0.5) {
    mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
    mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;
    raycaster.setFromCamera(mouse, camera);
    const plane = new THREE.Plane(new THREE.Vector3(0,1,0), -planeY);
    const point = new THREE.Vector3();
    raycaster.ray.intersectPlane(plane, point);
    return point;
}

// --- Mouse Events ---
function onMouseDown(event) {
    raycaster.setFromCamera(mouse, camera);
    const intersects = raycaster.intersectObjects(parts);
    if (intersects.length > 0) {
        selected = intersects[0].object;
        selected.material.color.set(0x00ff00);
        isDragging = true;
    } else {
        if (selected) resetColor(selected);
        selected = null;
    }
}

function onMouseMove(event) {
    if (!isDragging || !selected) return;
    const point = getMouseOnPlane(event, selected.position.y);
    selected.position.x = point.x;
    selected.position.z = point.z;
}

function onMouseUp(event) {
    if (selected) {
        selected.position.x = snapToGrid(selected.position.x);
        selected.position.z = snapToGrid(selected.position.z);
        resetColor(selected);
    }
    isDragging = false;
}

function resetColor(part) {
    if (part === parts[0]) part.material.color.set(0xffa500);
    else if (part === parts[1]) part.material.color.set(0x0000ff);
    else if (part === parts[2]) part.material.color.set(0xff0000);
    else part.material.color.set(0xffa500);
}

// --- Keyboard Events ---
// Rotate & scale selected
window.addEventListener('keydown', (e) => {
    if (!selected) return;
    switch(e.key.toLowerCase()) {
        case 'q': selected.rotation.y += Math.PI/16; break;
        case 'e': selected.rotation.y -= Math.PI/16; break;
        case 'z': selected.scale.multiplyScalar(0.9); break;
        case 'x': selected.scale.multiplyScalar(1.1); break;
        // Camera movement
        case 'w': camera.position.z -= 0.5; break;
        case 's': camera.position.z += 0.5; break;
        case 'a': camera.position.x -= 0.5; break;
        case 'd': camera.position.x += 0.5; break;
        case 'r': camera.position.y += 0.5; break;
        case 'f': camera.position.y -= 0.5; break;
    }
    camera.lookAt(0,0,0);
});

// --- Add new part button ---
document.getElementById('addPartBtn').addEventListener('click', () => {
    createPart(0xffa500, {x:0, y:parts.length*1+0.5, z:0});
});

// --- Event listeners ---
window.addEventListener('mousedown', (e)=>{mouse.x=(e.clientX/window.innerWidth)*2-1; mouse.y=-(e.clientY/window.innerHeight)*2+1; onMouseDown(e);});
window.addEventListener('mousemove', onMouseMove);
window.addEventListener('mouseup', onMouseUp);

// --- Animate ---
function animate() {
    requestAnimationFrame(animate);
    renderer.render(scene, camera);
}
animate();

// --- Resize ---
window.addEventListener('resize', ()=>{
    camera.aspect = window.innerWidth/window.innerHeight;
    camera.updateProjectionMatrix();
    renderer.setSize(window.innerWidth, window.innerHeight);
});
</script>

</body>
</html>
