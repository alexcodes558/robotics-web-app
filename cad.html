<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Robotics CAD</title>
    <style>
        body { margin: 0; overflow: hidden; }
        canvas { display: block; }
        button {
            position: absolute;
            top: 10px;
            left: 10px;
            z-index: 10;
            padding: 8px 12px;
            font-size: 16px;
        }
        #addPartBtn {
            position: absolute;
            top: 50px;
            left: 10px;
            z-index: 10;
            padding: 8px 12px;
            font-size: 16px;
        }
    </style>
</head>
<body>

<button onclick="window.history.back()">Back</button>
<button id="addPartBtn">Add Part</button>

<script type="module">
import * as THREE from 'https://cdn.jsdelivr.net/npm/three@0.152.2/build/three.module.js';

// --- Scene and Camera ---
const scene = new THREE.Scene();
const camera = new THREE.PerspectiveCamera(70, window.innerWidth/window.innerHeight, 0.1, 100);
camera.position.set(7, 7, 7);
camera.lookAt(0, 0, 0);

// --- Renderer ---
const renderer = new THREE.WebGLRenderer({antialias: true});
renderer.setSize(window.innerWidth, window.innerHeight);
document.body.appendChild(renderer.domElement);

// --- Build plate ---
const plate = new THREE.Mesh(
    new THREE.PlaneGeometry(10, 10),
    new THREE.MeshBasicMaterial({color: 0x808080, side: THREE.DoubleSide})
);
plate.rotation.x = -Math.PI/2;
scene.add(plate);

// --- Robot parts container ---
const parts = [];

// --- Function to create a part ---
function createPart(color=0xffa500, position={x:0, y:0.5, z:0}) {
    const cube = new THREE.Mesh(
        new THREE.BoxGeometry(1,1,1),
        new THREE.MeshBasicMaterial({color: color})
    );
    cube.position.set(position.x, position.y, position.z);
    scene.add(cube);
    parts.push(cube);
}

// --- Initial robot parts ---
createPart(0xffa500, {x:0, y:0.5, z:0});   // orange base
createPart(0x0000ff, {x:0, y:1.5, z:0});   // blue upper
createPart(0xff0000, {x:0, y:2.5, z:0});   // red head

// --- Raycaster & dragging ---
const raycaster = new THREE.Raycaster();
const mouse = new THREE.Vector2();
let selected = null;
let isDragging = false;

// --- Snap helper ---
function snapToGrid(value) {
    return Math.round(value * 2) / 2; // snap to 0.5 increments
}

function getMouseOnPlane(event, planeY = 0) {
    mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
    mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;
    raycaster.setFromCamera(mouse, camera);

    const plane = new THREE.Plane(new THREE.Vector3(0,1,0), -planeY);
    const point = new THREE.Vector3();
    raycaster.ray.intersectPlane(plane, point);
    return point;
}

// --- Mouse events ---
function onMouseDown(event) {
    raycaster.setFromCamera(
        {x: (event.clientX / window.innerWidth) * 2 - 1, y: -(event.clientY / window.innerHeight) * 2 + 1},
        camera
    );
    const intersects = raycaster.intersectObjects(parts);
    if (intersects.length > 0) {
        selected = intersects[0].object;
        selected.material.color.set(0x00ff00);
        isDragging = true;
    } else {
        if (selected) resetColor(selected);
        selected = null;
    }
}

function onMouseMove(event) {
    if (!isDragging || !selected) return;
    const point = getMouseOnPlane(event, selected.position.y);
    selected.position.x = point.x;
    selected.position.z = point.z;
}

function onMouseUp(event) {
    if (selected) {
        selected.position.x = snapToGrid(selected.position.x);
        selected.position.z = snapToGrid(selected.position.z);
        resetColor(selected);
    }
    isDragging = false;
}

// --- Keyboard rotation & scaling ---
window.addEventListener('keydown', (event) => {
    if (!selected) return;

    switch(event.key.toLowerCase()) {
        case 'q': // rotate left
            selected.rotation.y += Math.PI / 16;
            break;
        case 'e': // rotate right
            selected.rotation.y -= Math.PI / 16;
            break;
        case 'z': // scale down
            selected.scale.multiplyScalar(0.9);
            break;
        case 'x': // scale up
            selected.scale.multiplyScalar(1.1);
            break;
    }
}, false);

// --- Reset color helper ---
function resetColor(part) {
    if (part === parts[0]) part.material.color.set(0xffa500);
    else if (part === parts[1]) part.material.color.set(0x0000ff);
    else if (part === parts[2]) part.material.color.set(0xff0000);
    else part.material.color.set(0xffa500); // default for new parts
}

// --- Add new part button ---
document.getElementById('addPartBtn').addEventListener('click', () => {
    createPart(0xffa500, {x:0, y:parts.length*1 + 0.5, z:0});
});

// --- Event listeners ---
window.addEventListener('mousedown', onMouseDown, false);
window.addEventListener('mousemove', onMouseMove, false);
window.addEventListener('mouseup', onMouseUp, false);

// --- Animate ---
function animate() {
    requestAnimationFrame(animate);
    renderer.render(scene, camera);
}
animate();

// --- Handle resize ---
window.addEventListener('resize', () => {
    camera.aspect = window.innerWidth/window.innerHeight;
    camera.updateProjectionMatrix();
    renderer.setSize(window.innerWidth, window.innerHeight);
});
</script>

</body>
</html>
